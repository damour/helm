// Code generated by protoc-gen-go.
// source: hapi/services/tiller.proto
// DO NOT EDIT!

/*
Package services is a generated protocol buffer package.

It is generated from these files:
	hapi/services/tiller.proto

It has these top-level messages:
	ListReleasesRequest
	ListSort
	ListReleasesResponse
	GetReleaseStatusRequest
	GetReleaseStatusResponse
	GetReleaseContentRequest
	GetReleaseContentResponse
	UpdateReleaseRequest
	UpdateReleaseResponse
	RollbackReleaseRequest
	RollbackReleaseResponse
	InstallReleaseRequest
	LogItem
	InstallReleaseResponse
	UninstallReleaseRequest
	UninstallReleaseResponse
	GetVersionRequest
	GetVersionResponse
	GetHistoryRequest
	GetHistoryResponse
	TestReleaseRequest
	TestReleaseResponse
*/
package services

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import hapi_chart3 "k8s.io/helm/pkg/proto/hapi/chart"
import hapi_chart "k8s.io/helm/pkg/proto/hapi/chart"
import hapi_release5 "k8s.io/helm/pkg/proto/hapi/release"
import hapi_release4 "k8s.io/helm/pkg/proto/hapi/release"
import hapi_release1 "k8s.io/helm/pkg/proto/hapi/release"
import hapi_release3 "k8s.io/helm/pkg/proto/hapi/release"
import hapi_version "k8s.io/helm/pkg/proto/hapi/version"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// SortBy defines sort operations.
type ListSort_SortBy int32

const (
	ListSort_UNKNOWN       ListSort_SortBy = 0
	ListSort_NAME          ListSort_SortBy = 1
	ListSort_LAST_RELEASED ListSort_SortBy = 2
)

var ListSort_SortBy_name = map[int32]string{
	0: "UNKNOWN",
	1: "NAME",
	2: "LAST_RELEASED",
}
var ListSort_SortBy_value = map[string]int32{
	"UNKNOWN":       0,
	"NAME":          1,
	"LAST_RELEASED": 2,
}

func (x ListSort_SortBy) String() string {
	return proto.EnumName(ListSort_SortBy_name, int32(x))
}
func (ListSort_SortBy) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1, 0} }

// SortOrder defines sort orders to augment sorting operations.
type ListSort_SortOrder int32

const (
	ListSort_ASC  ListSort_SortOrder = 0
	ListSort_DESC ListSort_SortOrder = 1
)

var ListSort_SortOrder_name = map[int32]string{
	0: "ASC",
	1: "DESC",
}
var ListSort_SortOrder_value = map[string]int32{
	"ASC":  0,
	"DESC": 1,
}

func (x ListSort_SortOrder) String() string {
	return proto.EnumName(ListSort_SortOrder_name, int32(x))
}
func (ListSort_SortOrder) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1, 1} }

type LogItem_Level int32

const (
	LogItem_INFO  LogItem_Level = 0
	LogItem_ERROR LogItem_Level = 1
)

var LogItem_Level_name = map[int32]string{
	0: "INFO",
	1: "ERROR",
}
var LogItem_Level_value = map[string]int32{
	"INFO":  0,
	"ERROR": 1,
}

func (x LogItem_Level) String() string {
	return proto.EnumName(LogItem_Level_name, int32(x))
}
func (LogItem_Level) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{12, 0} }

// ListReleasesRequest requests a list of releases.
//
// Releases can be retrieved in chunks by setting limit and offset.
//
// Releases can be sorted according to a few pre-determined sort stategies.
type ListReleasesRequest struct {
	// Limit is the maximum number of releases to be returned.
	Limit int64 `protobuf:"varint,1,opt,name=limit" json:"limit,omitempty"`
	// Offset is the last release name that was seen. The next listing
	// operation will start with the name after this one.
	// Example: If list one returns albert, bernie, carl, and sets 'next: dennis'.
	// dennis is the offset. Supplying 'dennis' for the next request should
	// cause the next batch to return a set of results starting with 'dennis'.
	Offset string `protobuf:"bytes,2,opt,name=offset" json:"offset,omitempty"`
	// SortBy is the sort field that the ListReleases server should sort data before returning.
	SortBy ListSort_SortBy `protobuf:"varint,3,opt,name=sort_by,json=sortBy,enum=hapi.services.tiller.ListSort_SortBy" json:"sort_by,omitempty"`
	// Filter is a regular expression used to filter which releases should be listed.
	//
	// Anything that matches the regexp will be included in the results.
	Filter string `protobuf:"bytes,4,opt,name=filter" json:"filter,omitempty"`
	// SortOrder is the ordering directive used for sorting.
	SortOrder   ListSort_SortOrder          `protobuf:"varint,5,opt,name=sort_order,json=sortOrder,enum=hapi.services.tiller.ListSort_SortOrder" json:"sort_order,omitempty"`
	StatusCodes []hapi_release3.Status_Code `protobuf:"varint,6,rep,packed,name=status_codes,json=statusCodes,enum=hapi.release.Status_Code" json:"status_codes,omitempty"`
	// Namespace is the filter to select releases only from a specific namespace.
	Namespace string `protobuf:"bytes,7,opt,name=namespace" json:"namespace,omitempty"`
}

func (m *ListReleasesRequest) Reset()                    { *m = ListReleasesRequest{} }
func (m *ListReleasesRequest) String() string            { return proto.CompactTextString(m) }
func (*ListReleasesRequest) ProtoMessage()               {}
func (*ListReleasesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// ListSort defines sorting fields on a release list.
type ListSort struct {
}

func (m *ListSort) Reset()                    { *m = ListSort{} }
func (m *ListSort) String() string            { return proto.CompactTextString(m) }
func (*ListSort) ProtoMessage()               {}
func (*ListSort) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// ListReleasesResponse is a list of releases.
type ListReleasesResponse struct {
	// Count is the expected total number of releases to be returned.
	Count int64 `protobuf:"varint,1,opt,name=count" json:"count,omitempty"`
	// Next is the name of the next release. If this is other than an empty
	// string, it means there are more results.
	Next string `protobuf:"bytes,2,opt,name=next" json:"next,omitempty"`
	// Total is the total number of queryable releases.
	Total int64 `protobuf:"varint,3,opt,name=total" json:"total,omitempty"`
	// Releases is the list of found release objects.
	Releases []*hapi_release5.Release `protobuf:"bytes,4,rep,name=releases" json:"releases,omitempty"`
}

func (m *ListReleasesResponse) Reset()                    { *m = ListReleasesResponse{} }
func (m *ListReleasesResponse) String() string            { return proto.CompactTextString(m) }
func (*ListReleasesResponse) ProtoMessage()               {}
func (*ListReleasesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *ListReleasesResponse) GetReleases() []*hapi_release5.Release {
	if m != nil {
		return m.Releases
	}
	return nil
}

// GetReleaseStatusRequest is a request to get the status of a release.
type GetReleaseStatusRequest struct {
	// Name is the name of the release
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Version is the version of the release
	Version int32 `protobuf:"varint,2,opt,name=version" json:"version,omitempty"`
}

func (m *GetReleaseStatusRequest) Reset()                    { *m = GetReleaseStatusRequest{} }
func (m *GetReleaseStatusRequest) String() string            { return proto.CompactTextString(m) }
func (*GetReleaseStatusRequest) ProtoMessage()               {}
func (*GetReleaseStatusRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

// GetReleaseStatusResponse is the response indicating the status of the named release.
type GetReleaseStatusResponse struct {
	// Name is the name of the release.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Info contains information about the release.
	Info *hapi_release4.Info `protobuf:"bytes,2,opt,name=info" json:"info,omitempty"`
	// Namesapce the release was released into
	Namespace string `protobuf:"bytes,3,opt,name=namespace" json:"namespace,omitempty"`
}

func (m *GetReleaseStatusResponse) Reset()                    { *m = GetReleaseStatusResponse{} }
func (m *GetReleaseStatusResponse) String() string            { return proto.CompactTextString(m) }
func (*GetReleaseStatusResponse) ProtoMessage()               {}
func (*GetReleaseStatusResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *GetReleaseStatusResponse) GetInfo() *hapi_release4.Info {
	if m != nil {
		return m.Info
	}
	return nil
}

// GetReleaseContentRequest is a request to get the contents of a release.
type GetReleaseContentRequest struct {
	// The name of the release
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Version is the version of the release
	Version int32 `protobuf:"varint,2,opt,name=version" json:"version,omitempty"`
}

func (m *GetReleaseContentRequest) Reset()                    { *m = GetReleaseContentRequest{} }
func (m *GetReleaseContentRequest) String() string            { return proto.CompactTextString(m) }
func (*GetReleaseContentRequest) ProtoMessage()               {}
func (*GetReleaseContentRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

// GetReleaseContentResponse is a response containing the contents of a release.
type GetReleaseContentResponse struct {
	// The release content
	Release *hapi_release5.Release `protobuf:"bytes,1,opt,name=release" json:"release,omitempty"`
}

func (m *GetReleaseContentResponse) Reset()                    { *m = GetReleaseContentResponse{} }
func (m *GetReleaseContentResponse) String() string            { return proto.CompactTextString(m) }
func (*GetReleaseContentResponse) ProtoMessage()               {}
func (*GetReleaseContentResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *GetReleaseContentResponse) GetRelease() *hapi_release5.Release {
	if m != nil {
		return m.Release
	}
	return nil
}

// UpdateReleaseRequest updates a release.
type UpdateReleaseRequest struct {
	// The name of the release
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Chart is the protobuf representation of a chart.
	Chart *hapi_chart3.Chart `protobuf:"bytes,2,opt,name=chart" json:"chart,omitempty"`
	// Values is a string containing (unparsed) YAML values.
	Values *hapi_chart.Config `protobuf:"bytes,3,opt,name=values" json:"values,omitempty"`
	// dry_run, if true, will run through the release logic, but neither create
	DryRun bool `protobuf:"varint,4,opt,name=dry_run,json=dryRun" json:"dry_run,omitempty"`
	// DisableHooks causes the server to skip running any hooks for the upgrade.
	DisableHooks bool `protobuf:"varint,5,opt,name=disable_hooks,json=disableHooks" json:"disable_hooks,omitempty"`
	// Performs pods restart for resources if applicable
	Recreate bool `protobuf:"varint,6,opt,name=recreate" json:"recreate,omitempty"`
	// timeout specifies the max amount of time any kubernetes client command can run.
	Timeout int64 `protobuf:"varint,7,opt,name=timeout" json:"timeout,omitempty"`
	// ResetValues will cause Tiller to ignore stored values, resetting to default values.
	ResetValues bool `protobuf:"varint,8,opt,name=reset_values,json=resetValues" json:"reset_values,omitempty"`
	// wait, if true, will wait until all Pods, PVCs, and Services are in a ready state
	// before marking the release as successful. It will wait for as long as timeout
	Wait bool `protobuf:"varint,9,opt,name=wait" json:"wait,omitempty"`
	// ReuseValues will cause Tiller to reuse the values from the last release.
	// This is ignored if reset_values is set.
	ReuseValues bool `protobuf:"varint,10,opt,name=reuse_values,json=reuseValues" json:"reuse_values,omitempty"`
	// Force resource update through delete/recreate if needed.
	Force bool `protobuf:"varint,11,opt,name=force" json:"force,omitempty"`
}

func (m *UpdateReleaseRequest) Reset()                    { *m = UpdateReleaseRequest{} }
func (m *UpdateReleaseRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateReleaseRequest) ProtoMessage()               {}
func (*UpdateReleaseRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *UpdateReleaseRequest) GetChart() *hapi_chart3.Chart {
	if m != nil {
		return m.Chart
	}
	return nil
}

func (m *UpdateReleaseRequest) GetValues() *hapi_chart.Config {
	if m != nil {
		return m.Values
	}
	return nil
}

// UpdateReleaseResponse is the response to an update request.
type UpdateReleaseResponse struct {
	// One of the following will be filled in.
	//
	// Types that are valid to be assigned to Response:
	//	*UpdateReleaseResponse_Release
	//	*UpdateReleaseResponse_LogItem
	Response isUpdateReleaseResponse_Response `protobuf_oneof:"response"`
}

func (m *UpdateReleaseResponse) Reset()                    { *m = UpdateReleaseResponse{} }
func (m *UpdateReleaseResponse) String() string            { return proto.CompactTextString(m) }
func (*UpdateReleaseResponse) ProtoMessage()               {}
func (*UpdateReleaseResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

type isUpdateReleaseResponse_Response interface {
	isUpdateReleaseResponse_Response()
}

type UpdateReleaseResponse_Release struct {
	Release *hapi_release5.Release `protobuf:"bytes,1,opt,name=release,oneof"`
}
type UpdateReleaseResponse_LogItem struct {
	LogItem *LogItem `protobuf:"bytes,2,opt,name=logItem,oneof"`
}

func (*UpdateReleaseResponse_Release) isUpdateReleaseResponse_Response() {}
func (*UpdateReleaseResponse_LogItem) isUpdateReleaseResponse_Response() {}

func (m *UpdateReleaseResponse) GetResponse() isUpdateReleaseResponse_Response {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *UpdateReleaseResponse) GetRelease() *hapi_release5.Release {
	if x, ok := m.GetResponse().(*UpdateReleaseResponse_Release); ok {
		return x.Release
	}
	return nil
}

func (m *UpdateReleaseResponse) GetLogItem() *LogItem {
	if x, ok := m.GetResponse().(*UpdateReleaseResponse_LogItem); ok {
		return x.LogItem
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*UpdateReleaseResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _UpdateReleaseResponse_OneofMarshaler, _UpdateReleaseResponse_OneofUnmarshaler, _UpdateReleaseResponse_OneofSizer, []interface{}{
		(*UpdateReleaseResponse_Release)(nil),
		(*UpdateReleaseResponse_LogItem)(nil),
	}
}

func _UpdateReleaseResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*UpdateReleaseResponse)
	// response
	switch x := m.Response.(type) {
	case *UpdateReleaseResponse_Release:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Release); err != nil {
			return err
		}
	case *UpdateReleaseResponse_LogItem:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LogItem); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("UpdateReleaseResponse.Response has unexpected type %T", x)
	}
	return nil
}

func _UpdateReleaseResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*UpdateReleaseResponse)
	switch tag {
	case 1: // response.release
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(hapi_release5.Release)
		err := b.DecodeMessage(msg)
		m.Response = &UpdateReleaseResponse_Release{msg}
		return true, err
	case 2: // response.logItem
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LogItem)
		err := b.DecodeMessage(msg)
		m.Response = &UpdateReleaseResponse_LogItem{msg}
		return true, err
	default:
		return false, nil
	}
}

func _UpdateReleaseResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*UpdateReleaseResponse)
	// response
	switch x := m.Response.(type) {
	case *UpdateReleaseResponse_Release:
		s := proto.Size(x.Release)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *UpdateReleaseResponse_LogItem:
		s := proto.Size(x.LogItem)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type RollbackReleaseRequest struct {
	// The name of the release
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// dry_run, if true, will run through the release logic but no create
	DryRun bool `protobuf:"varint,2,opt,name=dry_run,json=dryRun" json:"dry_run,omitempty"`
	// DisableHooks causes the server to skip running any hooks for the rollback
	DisableHooks bool `protobuf:"varint,3,opt,name=disable_hooks,json=disableHooks" json:"disable_hooks,omitempty"`
	// Version is the version of the release to deploy.
	Version int32 `protobuf:"varint,4,opt,name=version" json:"version,omitempty"`
	// Performs pods restart for resources if applicable
	Recreate bool `protobuf:"varint,5,opt,name=recreate" json:"recreate,omitempty"`
	// timeout specifies the max amount of time any kubernetes client command can run.
	Timeout int64 `protobuf:"varint,6,opt,name=timeout" json:"timeout,omitempty"`
	// wait, if true, will wait until all Pods, PVCs, and Services are in a ready state
	// before marking the release as successful. It will wait for as long as timeout
	Wait bool `protobuf:"varint,7,opt,name=wait" json:"wait,omitempty"`
	// Force resource update through delete/recreate if needed.
	Force bool `protobuf:"varint,8,opt,name=force" json:"force,omitempty"`
}

func (m *RollbackReleaseRequest) Reset()                    { *m = RollbackReleaseRequest{} }
func (m *RollbackReleaseRequest) String() string            { return proto.CompactTextString(m) }
func (*RollbackReleaseRequest) ProtoMessage()               {}
func (*RollbackReleaseRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

// RollbackReleaseResponse is the response to an update request.
type RollbackReleaseResponse struct {
	// One of the following will be filled in.
	//
	// Types that are valid to be assigned to Response:
	//	*RollbackReleaseResponse_Release
	//	*RollbackReleaseResponse_LogItem
	Response isRollbackReleaseResponse_Response `protobuf_oneof:"response"`
}

func (m *RollbackReleaseResponse) Reset()                    { *m = RollbackReleaseResponse{} }
func (m *RollbackReleaseResponse) String() string            { return proto.CompactTextString(m) }
func (*RollbackReleaseResponse) ProtoMessage()               {}
func (*RollbackReleaseResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

type isRollbackReleaseResponse_Response interface {
	isRollbackReleaseResponse_Response()
}

type RollbackReleaseResponse_Release struct {
	Release *hapi_release5.Release `protobuf:"bytes,1,opt,name=release,oneof"`
}
type RollbackReleaseResponse_LogItem struct {
	LogItem *LogItem `protobuf:"bytes,2,opt,name=logItem,oneof"`
}

func (*RollbackReleaseResponse_Release) isRollbackReleaseResponse_Response() {}
func (*RollbackReleaseResponse_LogItem) isRollbackReleaseResponse_Response() {}

func (m *RollbackReleaseResponse) GetResponse() isRollbackReleaseResponse_Response {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *RollbackReleaseResponse) GetRelease() *hapi_release5.Release {
	if x, ok := m.GetResponse().(*RollbackReleaseResponse_Release); ok {
		return x.Release
	}
	return nil
}

func (m *RollbackReleaseResponse) GetLogItem() *LogItem {
	if x, ok := m.GetResponse().(*RollbackReleaseResponse_LogItem); ok {
		return x.LogItem
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RollbackReleaseResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RollbackReleaseResponse_OneofMarshaler, _RollbackReleaseResponse_OneofUnmarshaler, _RollbackReleaseResponse_OneofSizer, []interface{}{
		(*RollbackReleaseResponse_Release)(nil),
		(*RollbackReleaseResponse_LogItem)(nil),
	}
}

func _RollbackReleaseResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RollbackReleaseResponse)
	// response
	switch x := m.Response.(type) {
	case *RollbackReleaseResponse_Release:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Release); err != nil {
			return err
		}
	case *RollbackReleaseResponse_LogItem:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LogItem); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("RollbackReleaseResponse.Response has unexpected type %T", x)
	}
	return nil
}

func _RollbackReleaseResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RollbackReleaseResponse)
	switch tag {
	case 1: // response.release
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(hapi_release5.Release)
		err := b.DecodeMessage(msg)
		m.Response = &RollbackReleaseResponse_Release{msg}
		return true, err
	case 2: // response.logItem
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LogItem)
		err := b.DecodeMessage(msg)
		m.Response = &RollbackReleaseResponse_LogItem{msg}
		return true, err
	default:
		return false, nil
	}
}

func _RollbackReleaseResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RollbackReleaseResponse)
	// response
	switch x := m.Response.(type) {
	case *RollbackReleaseResponse_Release:
		s := proto.Size(x.Release)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RollbackReleaseResponse_LogItem:
		s := proto.Size(x.LogItem)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// InstallReleaseRequest is the request for an installation of a chart.
type InstallReleaseRequest struct {
	// Chart is the protobuf representation of a chart.
	Chart *hapi_chart3.Chart `protobuf:"bytes,1,opt,name=chart" json:"chart,omitempty"`
	// Values is a string containing (unparsed) YAML values.
	Values *hapi_chart.Config `protobuf:"bytes,2,opt,name=values" json:"values,omitempty"`
	// DryRun, if true, will run through the release logic, but neither create
	// a release object nor deploy to Kubernetes. The release object returned
	// in the response will be fake.
	DryRun bool `protobuf:"varint,3,opt,name=dry_run,json=dryRun" json:"dry_run,omitempty"`
	// Name is the candidate release name. This must be unique to the
	// namespace, otherwise the server will return an error. If it is not
	// supplied, the server will autogenerate one.
	Name string `protobuf:"bytes,4,opt,name=name" json:"name,omitempty"`
	// DisableHooks causes the server to skip running any hooks for the install.
	DisableHooks bool `protobuf:"varint,5,opt,name=disable_hooks,json=disableHooks" json:"disable_hooks,omitempty"`
	// Namepace is the kubernetes namespace of the release.
	Namespace string `protobuf:"bytes,6,opt,name=namespace" json:"namespace,omitempty"`
	// ReuseName requests that Tiller re-uses a name, instead of erroring out.
	ReuseName bool `protobuf:"varint,7,opt,name=reuse_name,json=reuseName" json:"reuse_name,omitempty"`
	// timeout specifies the max amount of time any kubernetes client command can run.
	Timeout int64 `protobuf:"varint,8,opt,name=timeout" json:"timeout,omitempty"`
	// wait, if true, will wait until all Pods, PVCs, and Services are in a ready state
	// before marking the release as successful. It will wait for as long as timeout
	Wait bool `protobuf:"varint,9,opt,name=wait" json:"wait,omitempty"`
}

func (m *InstallReleaseRequest) Reset()                    { *m = InstallReleaseRequest{} }
func (m *InstallReleaseRequest) String() string            { return proto.CompactTextString(m) }
func (*InstallReleaseRequest) ProtoMessage()               {}
func (*InstallReleaseRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *InstallReleaseRequest) GetChart() *hapi_chart3.Chart {
	if m != nil {
		return m.Chart
	}
	return nil
}

func (m *InstallReleaseRequest) GetValues() *hapi_chart.Config {
	if m != nil {
		return m.Values
	}
	return nil
}

type LogItem struct {
	Level   LogItem_Level `protobuf:"varint,1,opt,name=level,enum=hapi.services.tiller.LogItem_Level" json:"level,omitempty"`
	Message string        `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
}

func (m *LogItem) Reset()                    { *m = LogItem{} }
func (m *LogItem) String() string            { return proto.CompactTextString(m) }
func (*LogItem) ProtoMessage()               {}
func (*LogItem) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

// InstallReleaseResponse is the response from a release installation.
type InstallReleaseResponse struct {
	// One of the following will be filled in.
	//
	// Types that are valid to be assigned to Response:
	//	*InstallReleaseResponse_Release
	//	*InstallReleaseResponse_LogItem
	Response isInstallReleaseResponse_Response `protobuf_oneof:"response"`
}

func (m *InstallReleaseResponse) Reset()                    { *m = InstallReleaseResponse{} }
func (m *InstallReleaseResponse) String() string            { return proto.CompactTextString(m) }
func (*InstallReleaseResponse) ProtoMessage()               {}
func (*InstallReleaseResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

type isInstallReleaseResponse_Response interface {
	isInstallReleaseResponse_Response()
}

type InstallReleaseResponse_Release struct {
	Release *hapi_release5.Release `protobuf:"bytes,1,opt,name=release,oneof"`
}
type InstallReleaseResponse_LogItem struct {
	LogItem *LogItem `protobuf:"bytes,2,opt,name=logItem,oneof"`
}

func (*InstallReleaseResponse_Release) isInstallReleaseResponse_Response() {}
func (*InstallReleaseResponse_LogItem) isInstallReleaseResponse_Response() {}

func (m *InstallReleaseResponse) GetResponse() isInstallReleaseResponse_Response {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *InstallReleaseResponse) GetRelease() *hapi_release5.Release {
	if x, ok := m.GetResponse().(*InstallReleaseResponse_Release); ok {
		return x.Release
	}
	return nil
}

func (m *InstallReleaseResponse) GetLogItem() *LogItem {
	if x, ok := m.GetResponse().(*InstallReleaseResponse_LogItem); ok {
		return x.LogItem
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*InstallReleaseResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _InstallReleaseResponse_OneofMarshaler, _InstallReleaseResponse_OneofUnmarshaler, _InstallReleaseResponse_OneofSizer, []interface{}{
		(*InstallReleaseResponse_Release)(nil),
		(*InstallReleaseResponse_LogItem)(nil),
	}
}

func _InstallReleaseResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*InstallReleaseResponse)
	// response
	switch x := m.Response.(type) {
	case *InstallReleaseResponse_Release:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Release); err != nil {
			return err
		}
	case *InstallReleaseResponse_LogItem:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LogItem); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("InstallReleaseResponse.Response has unexpected type %T", x)
	}
	return nil
}

func _InstallReleaseResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*InstallReleaseResponse)
	switch tag {
	case 1: // response.release
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(hapi_release5.Release)
		err := b.DecodeMessage(msg)
		m.Response = &InstallReleaseResponse_Release{msg}
		return true, err
	case 2: // response.logItem
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LogItem)
		err := b.DecodeMessage(msg)
		m.Response = &InstallReleaseResponse_LogItem{msg}
		return true, err
	default:
		return false, nil
	}
}

func _InstallReleaseResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*InstallReleaseResponse)
	// response
	switch x := m.Response.(type) {
	case *InstallReleaseResponse_Release:
		s := proto.Size(x.Release)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *InstallReleaseResponse_LogItem:
		s := proto.Size(x.LogItem)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// UninstallReleaseRequest represents a request to uninstall a named release.
type UninstallReleaseRequest struct {
	// Name is the name of the release to delete.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// DisableHooks causes the server to skip running any hooks for the uninstall.
	DisableHooks bool `protobuf:"varint,2,opt,name=disable_hooks,json=disableHooks" json:"disable_hooks,omitempty"`
	// Purge removes the release from the store and make its name free for later use.
	Purge bool `protobuf:"varint,3,opt,name=purge" json:"purge,omitempty"`
	// timeout specifies the max amount of time any kubernetes client command can run.
	Timeout int64 `protobuf:"varint,4,opt,name=timeout" json:"timeout,omitempty"`
}

func (m *UninstallReleaseRequest) Reset()                    { *m = UninstallReleaseRequest{} }
func (m *UninstallReleaseRequest) String() string            { return proto.CompactTextString(m) }
func (*UninstallReleaseRequest) ProtoMessage()               {}
func (*UninstallReleaseRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

// UninstallReleaseResponse represents a successful response to an uninstall request.
type UninstallReleaseResponse struct {
	// One of the following will be filled in.
	//
	// Types that are valid to be assigned to Response:
	//	*UninstallReleaseResponse_Release
	//	*UninstallReleaseResponse_Info
	//	*UninstallReleaseResponse_LogItem
	Response isUninstallReleaseResponse_Response `protobuf_oneof:"response"`
}

func (m *UninstallReleaseResponse) Reset()                    { *m = UninstallReleaseResponse{} }
func (m *UninstallReleaseResponse) String() string            { return proto.CompactTextString(m) }
func (*UninstallReleaseResponse) ProtoMessage()               {}
func (*UninstallReleaseResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

type isUninstallReleaseResponse_Response interface {
	isUninstallReleaseResponse_Response()
}

type UninstallReleaseResponse_Release struct {
	Release *hapi_release5.Release `protobuf:"bytes,1,opt,name=release,oneof"`
}
type UninstallReleaseResponse_Info struct {
	Info string `protobuf:"bytes,2,opt,name=info,oneof"`
}
type UninstallReleaseResponse_LogItem struct {
	LogItem *LogItem `protobuf:"bytes,3,opt,name=logItem,oneof"`
}

func (*UninstallReleaseResponse_Release) isUninstallReleaseResponse_Response() {}
func (*UninstallReleaseResponse_Info) isUninstallReleaseResponse_Response()    {}
func (*UninstallReleaseResponse_LogItem) isUninstallReleaseResponse_Response() {}

func (m *UninstallReleaseResponse) GetResponse() isUninstallReleaseResponse_Response {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *UninstallReleaseResponse) GetRelease() *hapi_release5.Release {
	if x, ok := m.GetResponse().(*UninstallReleaseResponse_Release); ok {
		return x.Release
	}
	return nil
}

func (m *UninstallReleaseResponse) GetInfo() string {
	if x, ok := m.GetResponse().(*UninstallReleaseResponse_Info); ok {
		return x.Info
	}
	return ""
}

func (m *UninstallReleaseResponse) GetLogItem() *LogItem {
	if x, ok := m.GetResponse().(*UninstallReleaseResponse_LogItem); ok {
		return x.LogItem
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*UninstallReleaseResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _UninstallReleaseResponse_OneofMarshaler, _UninstallReleaseResponse_OneofUnmarshaler, _UninstallReleaseResponse_OneofSizer, []interface{}{
		(*UninstallReleaseResponse_Release)(nil),
		(*UninstallReleaseResponse_Info)(nil),
		(*UninstallReleaseResponse_LogItem)(nil),
	}
}

func _UninstallReleaseResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*UninstallReleaseResponse)
	// response
	switch x := m.Response.(type) {
	case *UninstallReleaseResponse_Release:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Release); err != nil {
			return err
		}
	case *UninstallReleaseResponse_Info:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Info)
	case *UninstallReleaseResponse_LogItem:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LogItem); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("UninstallReleaseResponse.Response has unexpected type %T", x)
	}
	return nil
}

func _UninstallReleaseResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*UninstallReleaseResponse)
	switch tag {
	case 1: // response.release
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(hapi_release5.Release)
		err := b.DecodeMessage(msg)
		m.Response = &UninstallReleaseResponse_Release{msg}
		return true, err
	case 2: // response.info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Response = &UninstallReleaseResponse_Info{x}
		return true, err
	case 3: // response.logItem
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LogItem)
		err := b.DecodeMessage(msg)
		m.Response = &UninstallReleaseResponse_LogItem{msg}
		return true, err
	default:
		return false, nil
	}
}

func _UninstallReleaseResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*UninstallReleaseResponse)
	// response
	switch x := m.Response.(type) {
	case *UninstallReleaseResponse_Release:
		s := proto.Size(x.Release)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *UninstallReleaseResponse_Info:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Info)))
		n += len(x.Info)
	case *UninstallReleaseResponse_LogItem:
		s := proto.Size(x.LogItem)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// GetVersionRequest requests for version information.
type GetVersionRequest struct {
}

func (m *GetVersionRequest) Reset()                    { *m = GetVersionRequest{} }
func (m *GetVersionRequest) String() string            { return proto.CompactTextString(m) }
func (*GetVersionRequest) ProtoMessage()               {}
func (*GetVersionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

type GetVersionResponse struct {
	Version *hapi_version.Version `protobuf:"bytes,1,opt,name=Version" json:"Version,omitempty"`
}

func (m *GetVersionResponse) Reset()                    { *m = GetVersionResponse{} }
func (m *GetVersionResponse) String() string            { return proto.CompactTextString(m) }
func (*GetVersionResponse) ProtoMessage()               {}
func (*GetVersionResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *GetVersionResponse) GetVersion() *hapi_version.Version {
	if m != nil {
		return m.Version
	}
	return nil
}

// GetHistoryRequest requests a release's history.
type GetHistoryRequest struct {
	// The name of the release.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// The maximum number of releases to include.
	Max int32 `protobuf:"varint,2,opt,name=max" json:"max,omitempty"`
}

func (m *GetHistoryRequest) Reset()                    { *m = GetHistoryRequest{} }
func (m *GetHistoryRequest) String() string            { return proto.CompactTextString(m) }
func (*GetHistoryRequest) ProtoMessage()               {}
func (*GetHistoryRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

// GetHistoryResponse is received in response to a GetHistory rpc.
type GetHistoryResponse struct {
	Releases []*hapi_release5.Release `protobuf:"bytes,1,rep,name=releases" json:"releases,omitempty"`
}

func (m *GetHistoryResponse) Reset()                    { *m = GetHistoryResponse{} }
func (m *GetHistoryResponse) String() string            { return proto.CompactTextString(m) }
func (*GetHistoryResponse) ProtoMessage()               {}
func (*GetHistoryResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *GetHistoryResponse) GetReleases() []*hapi_release5.Release {
	if m != nil {
		return m.Releases
	}
	return nil
}

// TestReleaseRequest is a request to get the status of a release.
type TestReleaseRequest struct {
	// Name is the name of the release
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// timeout specifies the max amount of time any kubernetes client command can run.
	Timeout int64 `protobuf:"varint,2,opt,name=timeout" json:"timeout,omitempty"`
	// cleanup specifies whether or not to attempt pod deletion after test completes
	Cleanup bool `protobuf:"varint,3,opt,name=cleanup" json:"cleanup,omitempty"`
}

func (m *TestReleaseRequest) Reset()                    { *m = TestReleaseRequest{} }
func (m *TestReleaseRequest) String() string            { return proto.CompactTextString(m) }
func (*TestReleaseRequest) ProtoMessage()               {}
func (*TestReleaseRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

// TestReleaseResponse represents a message from executing a test
type TestReleaseResponse struct {
	Msg    string                       `protobuf:"bytes,1,opt,name=msg" json:"msg,omitempty"`
	Status hapi_release1.TestRun_Status `protobuf:"varint,2,opt,name=status,enum=hapi.release.TestRun_Status" json:"status,omitempty"`
}

func (m *TestReleaseResponse) Reset()                    { *m = TestReleaseResponse{} }
func (m *TestReleaseResponse) String() string            { return proto.CompactTextString(m) }
func (*TestReleaseResponse) ProtoMessage()               {}
func (*TestReleaseResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func init() {
	proto.RegisterType((*ListReleasesRequest)(nil), "hapi.services.tiller.ListReleasesRequest")
	proto.RegisterType((*ListSort)(nil), "hapi.services.tiller.ListSort")
	proto.RegisterType((*ListReleasesResponse)(nil), "hapi.services.tiller.ListReleasesResponse")
	proto.RegisterType((*GetReleaseStatusRequest)(nil), "hapi.services.tiller.GetReleaseStatusRequest")
	proto.RegisterType((*GetReleaseStatusResponse)(nil), "hapi.services.tiller.GetReleaseStatusResponse")
	proto.RegisterType((*GetReleaseContentRequest)(nil), "hapi.services.tiller.GetReleaseContentRequest")
	proto.RegisterType((*GetReleaseContentResponse)(nil), "hapi.services.tiller.GetReleaseContentResponse")
	proto.RegisterType((*UpdateReleaseRequest)(nil), "hapi.services.tiller.UpdateReleaseRequest")
	proto.RegisterType((*UpdateReleaseResponse)(nil), "hapi.services.tiller.UpdateReleaseResponse")
	proto.RegisterType((*RollbackReleaseRequest)(nil), "hapi.services.tiller.RollbackReleaseRequest")
	proto.RegisterType((*RollbackReleaseResponse)(nil), "hapi.services.tiller.RollbackReleaseResponse")
	proto.RegisterType((*InstallReleaseRequest)(nil), "hapi.services.tiller.InstallReleaseRequest")
	proto.RegisterType((*LogItem)(nil), "hapi.services.tiller.LogItem")
	proto.RegisterType((*InstallReleaseResponse)(nil), "hapi.services.tiller.InstallReleaseResponse")
	proto.RegisterType((*UninstallReleaseRequest)(nil), "hapi.services.tiller.UninstallReleaseRequest")
	proto.RegisterType((*UninstallReleaseResponse)(nil), "hapi.services.tiller.UninstallReleaseResponse")
	proto.RegisterType((*GetVersionRequest)(nil), "hapi.services.tiller.GetVersionRequest")
	proto.RegisterType((*GetVersionResponse)(nil), "hapi.services.tiller.GetVersionResponse")
	proto.RegisterType((*GetHistoryRequest)(nil), "hapi.services.tiller.GetHistoryRequest")
	proto.RegisterType((*GetHistoryResponse)(nil), "hapi.services.tiller.GetHistoryResponse")
	proto.RegisterType((*TestReleaseRequest)(nil), "hapi.services.tiller.TestReleaseRequest")
	proto.RegisterType((*TestReleaseResponse)(nil), "hapi.services.tiller.TestReleaseResponse")
	proto.RegisterEnum("hapi.services.tiller.ListSort_SortBy", ListSort_SortBy_name, ListSort_SortBy_value)
	proto.RegisterEnum("hapi.services.tiller.ListSort_SortOrder", ListSort_SortOrder_name, ListSort_SortOrder_value)
	proto.RegisterEnum("hapi.services.tiller.LogItem_Level", LogItem_Level_name, LogItem_Level_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ReleaseService service

type ReleaseServiceClient interface {
	// ListReleases retrieves release history.
	// TODO: Allow filtering the set of releases by
	// release status. By default, ListAllReleases returns the releases who
	// current status is "Active".
	ListReleases(ctx context.Context, in *ListReleasesRequest, opts ...grpc.CallOption) (ReleaseService_ListReleasesClient, error)
	// GetReleasesStatus retrieves status information for the specified release.
	GetReleaseStatus(ctx context.Context, in *GetReleaseStatusRequest, opts ...grpc.CallOption) (*GetReleaseStatusResponse, error)
	// GetReleaseContent retrieves the release content (chart + value) for the specified release.
	GetReleaseContent(ctx context.Context, in *GetReleaseContentRequest, opts ...grpc.CallOption) (*GetReleaseContentResponse, error)
	// UpdateRelease updates release content.
	UpdateRelease(ctx context.Context, in *UpdateReleaseRequest, opts ...grpc.CallOption) (ReleaseService_UpdateReleaseClient, error)
	// InstallRelease requests installation of a chart as a new release.
	InstallRelease(ctx context.Context, in *InstallReleaseRequest, opts ...grpc.CallOption) (ReleaseService_InstallReleaseClient, error)
	// UninstallRelease requests deletion of a named release.
	UninstallRelease(ctx context.Context, in *UninstallReleaseRequest, opts ...grpc.CallOption) (ReleaseService_UninstallReleaseClient, error)
	// GetVersion returns the current version of the server.
	GetVersion(ctx context.Context, in *GetVersionRequest, opts ...grpc.CallOption) (*GetVersionResponse, error)
	// RollbackRelease rolls back a release to a previous version.
	RollbackRelease(ctx context.Context, in *RollbackReleaseRequest, opts ...grpc.CallOption) (ReleaseService_RollbackReleaseClient, error)
	// ReleaseHistory retrieves a releasse's history.
	GetHistory(ctx context.Context, in *GetHistoryRequest, opts ...grpc.CallOption) (*GetHistoryResponse, error)
	// RunReleaseTest executes the tests defined of a named release
	RunReleaseTest(ctx context.Context, in *TestReleaseRequest, opts ...grpc.CallOption) (ReleaseService_RunReleaseTestClient, error)
}

type releaseServiceClient struct {
	cc *grpc.ClientConn
}

func NewReleaseServiceClient(cc *grpc.ClientConn) ReleaseServiceClient {
	return &releaseServiceClient{cc}
}

func (c *releaseServiceClient) ListReleases(ctx context.Context, in *ListReleasesRequest, opts ...grpc.CallOption) (ReleaseService_ListReleasesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ReleaseService_serviceDesc.Streams[0], c.cc, "/hapi.services.tiller.ReleaseService/ListReleases", opts...)
	if err != nil {
		return nil, err
	}
	x := &releaseServiceListReleasesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ReleaseService_ListReleasesClient interface {
	Recv() (*ListReleasesResponse, error)
	grpc.ClientStream
}

type releaseServiceListReleasesClient struct {
	grpc.ClientStream
}

func (x *releaseServiceListReleasesClient) Recv() (*ListReleasesResponse, error) {
	m := new(ListReleasesResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *releaseServiceClient) GetReleaseStatus(ctx context.Context, in *GetReleaseStatusRequest, opts ...grpc.CallOption) (*GetReleaseStatusResponse, error) {
	out := new(GetReleaseStatusResponse)
	err := grpc.Invoke(ctx, "/hapi.services.tiller.ReleaseService/GetReleaseStatus", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *releaseServiceClient) GetReleaseContent(ctx context.Context, in *GetReleaseContentRequest, opts ...grpc.CallOption) (*GetReleaseContentResponse, error) {
	out := new(GetReleaseContentResponse)
	err := grpc.Invoke(ctx, "/hapi.services.tiller.ReleaseService/GetReleaseContent", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *releaseServiceClient) UpdateRelease(ctx context.Context, in *UpdateReleaseRequest, opts ...grpc.CallOption) (ReleaseService_UpdateReleaseClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ReleaseService_serviceDesc.Streams[1], c.cc, "/hapi.services.tiller.ReleaseService/UpdateRelease", opts...)
	if err != nil {
		return nil, err
	}
	x := &releaseServiceUpdateReleaseClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ReleaseService_UpdateReleaseClient interface {
	Recv() (*UpdateReleaseResponse, error)
	grpc.ClientStream
}

type releaseServiceUpdateReleaseClient struct {
	grpc.ClientStream
}

func (x *releaseServiceUpdateReleaseClient) Recv() (*UpdateReleaseResponse, error) {
	m := new(UpdateReleaseResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *releaseServiceClient) InstallRelease(ctx context.Context, in *InstallReleaseRequest, opts ...grpc.CallOption) (ReleaseService_InstallReleaseClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ReleaseService_serviceDesc.Streams[2], c.cc, "/hapi.services.tiller.ReleaseService/InstallRelease", opts...)
	if err != nil {
		return nil, err
	}
	x := &releaseServiceInstallReleaseClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ReleaseService_InstallReleaseClient interface {
	Recv() (*InstallReleaseResponse, error)
	grpc.ClientStream
}

type releaseServiceInstallReleaseClient struct {
	grpc.ClientStream
}

func (x *releaseServiceInstallReleaseClient) Recv() (*InstallReleaseResponse, error) {
	m := new(InstallReleaseResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *releaseServiceClient) UninstallRelease(ctx context.Context, in *UninstallReleaseRequest, opts ...grpc.CallOption) (ReleaseService_UninstallReleaseClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ReleaseService_serviceDesc.Streams[3], c.cc, "/hapi.services.tiller.ReleaseService/UninstallRelease", opts...)
	if err != nil {
		return nil, err
	}
	x := &releaseServiceUninstallReleaseClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ReleaseService_UninstallReleaseClient interface {
	Recv() (*UninstallReleaseResponse, error)
	grpc.ClientStream
}

type releaseServiceUninstallReleaseClient struct {
	grpc.ClientStream
}

func (x *releaseServiceUninstallReleaseClient) Recv() (*UninstallReleaseResponse, error) {
	m := new(UninstallReleaseResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *releaseServiceClient) GetVersion(ctx context.Context, in *GetVersionRequest, opts ...grpc.CallOption) (*GetVersionResponse, error) {
	out := new(GetVersionResponse)
	err := grpc.Invoke(ctx, "/hapi.services.tiller.ReleaseService/GetVersion", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *releaseServiceClient) RollbackRelease(ctx context.Context, in *RollbackReleaseRequest, opts ...grpc.CallOption) (ReleaseService_RollbackReleaseClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ReleaseService_serviceDesc.Streams[4], c.cc, "/hapi.services.tiller.ReleaseService/RollbackRelease", opts...)
	if err != nil {
		return nil, err
	}
	x := &releaseServiceRollbackReleaseClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ReleaseService_RollbackReleaseClient interface {
	Recv() (*RollbackReleaseResponse, error)
	grpc.ClientStream
}

type releaseServiceRollbackReleaseClient struct {
	grpc.ClientStream
}

func (x *releaseServiceRollbackReleaseClient) Recv() (*RollbackReleaseResponse, error) {
	m := new(RollbackReleaseResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *releaseServiceClient) GetHistory(ctx context.Context, in *GetHistoryRequest, opts ...grpc.CallOption) (*GetHistoryResponse, error) {
	out := new(GetHistoryResponse)
	err := grpc.Invoke(ctx, "/hapi.services.tiller.ReleaseService/GetHistory", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *releaseServiceClient) RunReleaseTest(ctx context.Context, in *TestReleaseRequest, opts ...grpc.CallOption) (ReleaseService_RunReleaseTestClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ReleaseService_serviceDesc.Streams[5], c.cc, "/hapi.services.tiller.ReleaseService/RunReleaseTest", opts...)
	if err != nil {
		return nil, err
	}
	x := &releaseServiceRunReleaseTestClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ReleaseService_RunReleaseTestClient interface {
	Recv() (*TestReleaseResponse, error)
	grpc.ClientStream
}

type releaseServiceRunReleaseTestClient struct {
	grpc.ClientStream
}

func (x *releaseServiceRunReleaseTestClient) Recv() (*TestReleaseResponse, error) {
	m := new(TestReleaseResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for ReleaseService service

type ReleaseServiceServer interface {
	// ListReleases retrieves release history.
	// TODO: Allow filtering the set of releases by
	// release status. By default, ListAllReleases returns the releases who
	// current status is "Active".
	ListReleases(*ListReleasesRequest, ReleaseService_ListReleasesServer) error
	// GetReleasesStatus retrieves status information for the specified release.
	GetReleaseStatus(context.Context, *GetReleaseStatusRequest) (*GetReleaseStatusResponse, error)
	// GetReleaseContent retrieves the release content (chart + value) for the specified release.
	GetReleaseContent(context.Context, *GetReleaseContentRequest) (*GetReleaseContentResponse, error)
	// UpdateRelease updates release content.
	UpdateRelease(*UpdateReleaseRequest, ReleaseService_UpdateReleaseServer) error
	// InstallRelease requests installation of a chart as a new release.
	InstallRelease(*InstallReleaseRequest, ReleaseService_InstallReleaseServer) error
	// UninstallRelease requests deletion of a named release.
	UninstallRelease(*UninstallReleaseRequest, ReleaseService_UninstallReleaseServer) error
	// GetVersion returns the current version of the server.
	GetVersion(context.Context, *GetVersionRequest) (*GetVersionResponse, error)
	// RollbackRelease rolls back a release to a previous version.
	RollbackRelease(*RollbackReleaseRequest, ReleaseService_RollbackReleaseServer) error
	// ReleaseHistory retrieves a releasse's history.
	GetHistory(context.Context, *GetHistoryRequest) (*GetHistoryResponse, error)
	// RunReleaseTest executes the tests defined of a named release
	RunReleaseTest(*TestReleaseRequest, ReleaseService_RunReleaseTestServer) error
}

func RegisterReleaseServiceServer(s *grpc.Server, srv ReleaseServiceServer) {
	s.RegisterService(&_ReleaseService_serviceDesc, srv)
}

func _ReleaseService_ListReleases_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListReleasesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ReleaseServiceServer).ListReleases(m, &releaseServiceListReleasesServer{stream})
}

type ReleaseService_ListReleasesServer interface {
	Send(*ListReleasesResponse) error
	grpc.ServerStream
}

type releaseServiceListReleasesServer struct {
	grpc.ServerStream
}

func (x *releaseServiceListReleasesServer) Send(m *ListReleasesResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _ReleaseService_GetReleaseStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetReleaseStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReleaseServiceServer).GetReleaseStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hapi.services.tiller.ReleaseService/GetReleaseStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReleaseServiceServer).GetReleaseStatus(ctx, req.(*GetReleaseStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReleaseService_GetReleaseContent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetReleaseContentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReleaseServiceServer).GetReleaseContent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hapi.services.tiller.ReleaseService/GetReleaseContent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReleaseServiceServer).GetReleaseContent(ctx, req.(*GetReleaseContentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReleaseService_UpdateRelease_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(UpdateReleaseRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ReleaseServiceServer).UpdateRelease(m, &releaseServiceUpdateReleaseServer{stream})
}

type ReleaseService_UpdateReleaseServer interface {
	Send(*UpdateReleaseResponse) error
	grpc.ServerStream
}

type releaseServiceUpdateReleaseServer struct {
	grpc.ServerStream
}

func (x *releaseServiceUpdateReleaseServer) Send(m *UpdateReleaseResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _ReleaseService_InstallRelease_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(InstallReleaseRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ReleaseServiceServer).InstallRelease(m, &releaseServiceInstallReleaseServer{stream})
}

type ReleaseService_InstallReleaseServer interface {
	Send(*InstallReleaseResponse) error
	grpc.ServerStream
}

type releaseServiceInstallReleaseServer struct {
	grpc.ServerStream
}

func (x *releaseServiceInstallReleaseServer) Send(m *InstallReleaseResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _ReleaseService_UninstallRelease_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(UninstallReleaseRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ReleaseServiceServer).UninstallRelease(m, &releaseServiceUninstallReleaseServer{stream})
}

type ReleaseService_UninstallReleaseServer interface {
	Send(*UninstallReleaseResponse) error
	grpc.ServerStream
}

type releaseServiceUninstallReleaseServer struct {
	grpc.ServerStream
}

func (x *releaseServiceUninstallReleaseServer) Send(m *UninstallReleaseResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _ReleaseService_GetVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReleaseServiceServer).GetVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hapi.services.tiller.ReleaseService/GetVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReleaseServiceServer).GetVersion(ctx, req.(*GetVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReleaseService_RollbackRelease_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RollbackReleaseRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ReleaseServiceServer).RollbackRelease(m, &releaseServiceRollbackReleaseServer{stream})
}

type ReleaseService_RollbackReleaseServer interface {
	Send(*RollbackReleaseResponse) error
	grpc.ServerStream
}

type releaseServiceRollbackReleaseServer struct {
	grpc.ServerStream
}

func (x *releaseServiceRollbackReleaseServer) Send(m *RollbackReleaseResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _ReleaseService_GetHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReleaseServiceServer).GetHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hapi.services.tiller.ReleaseService/GetHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReleaseServiceServer).GetHistory(ctx, req.(*GetHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReleaseService_RunReleaseTest_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TestReleaseRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ReleaseServiceServer).RunReleaseTest(m, &releaseServiceRunReleaseTestServer{stream})
}

type ReleaseService_RunReleaseTestServer interface {
	Send(*TestReleaseResponse) error
	grpc.ServerStream
}

type releaseServiceRunReleaseTestServer struct {
	grpc.ServerStream
}

func (x *releaseServiceRunReleaseTestServer) Send(m *TestReleaseResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _ReleaseService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "hapi.services.tiller.ReleaseService",
	HandlerType: (*ReleaseServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetReleaseStatus",
			Handler:    _ReleaseService_GetReleaseStatus_Handler,
		},
		{
			MethodName: "GetReleaseContent",
			Handler:    _ReleaseService_GetReleaseContent_Handler,
		},
		{
			MethodName: "GetVersion",
			Handler:    _ReleaseService_GetVersion_Handler,
		},
		{
			MethodName: "GetHistory",
			Handler:    _ReleaseService_GetHistory_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListReleases",
			Handler:       _ReleaseService_ListReleases_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "UpdateRelease",
			Handler:       _ReleaseService_UpdateRelease_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "InstallRelease",
			Handler:       _ReleaseService_InstallRelease_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "UninstallRelease",
			Handler:       _ReleaseService_UninstallRelease_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RollbackRelease",
			Handler:       _ReleaseService_RollbackRelease_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RunReleaseTest",
			Handler:       _ReleaseService_RunReleaseTest_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "hapi/services/tiller.proto",
}

func init() { proto.RegisterFile("hapi/services/tiller.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1325 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x58, 0xdd, 0x6e, 0x1b, 0x45,
	0x14, 0xce, 0xfa, 0xdf, 0x27, 0xa9, 0x71, 0xa7, 0x6e, 0xb2, 0x35, 0x2d, 0x0a, 0x5b, 0x41, 0xdd,
	0x42, 0x1d, 0x6a, 0xb8, 0xa9, 0x84, 0x90, 0xd2, 0xd4, 0x24, 0x11, 0x21, 0x91, 0x26, 0x6d, 0x91,
	0x10, 0x10, 0x6d, 0xec, 0x71, 0xba, 0xea, 0x7a, 0xc7, 0xec, 0xcc, 0x86, 0x46, 0xe2, 0x8a, 0x3b,
	0x2e, 0x81, 0xa7, 0x80, 0xa7, 0xe0, 0x5d, 0xca, 0x83, 0xa0, 0xf9, 0xdb, 0xec, 0x38, 0xde, 0x74,
	0x29, 0x17, 0xbd, 0xf1, 0xce, 0xcc, 0xf9, 0x9d, 0xef, 0x9b, 0x39, 0x73, 0x12, 0xe8, 0x3e, 0xf7,
	0x67, 0xc1, 0x06, 0x23, 0xf1, 0x69, 0x30, 0x22, 0x6c, 0x83, 0x07, 0x61, 0x48, 0xe2, 0xfe, 0x2c,
	0xa6, 0x9c, 0xa2, 0x8e, 0x90, 0xf5, 0x8d, 0xac, 0xaf, 0x64, 0xdd, 0x55, 0x69, 0x31, 0x7a, 0xee,
	0xc7, 0x5c, 0xfd, 0x2a, 0xed, 0xee, 0x5a, 0x76, 0x9d, 0x46, 0x93, 0xe0, 0x44, 0x0b, 0x54, 0x88,
	0x98, 0x84, 0xc4, 0x67, 0xc4, 0x7c, 0x2d, 0x23, 0x23, 0x0b, 0xa2, 0x09, 0xd5, 0x82, 0x77, 0x2d,
	0x01, 0x27, 0x8c, 0x1f, 0xc5, 0x49, 0xa4, 0x85, 0x37, 0x2c, 0x21, 0xe3, 0x3e, 0x4f, 0x98, 0x15,
	0xec, 0x94, 0xc4, 0x2c, 0xa0, 0x91, 0xf9, 0x2a, 0x99, 0xf7, 0x77, 0x09, 0xae, 0xed, 0x05, 0x8c,
	0x63, 0x65, 0xc8, 0x30, 0xf9, 0x31, 0x21, 0x8c, 0xa3, 0x0e, 0x54, 0xc3, 0x60, 0x1a, 0x70, 0xd7,
	0x59, 0x77, 0x7a, 0x65, 0xac, 0x26, 0x68, 0x15, 0x6a, 0x74, 0x32, 0x61, 0x84, 0xbb, 0xa5, 0x75,
	0xa7, 0xd7, 0xc4, 0x7a, 0x86, 0xbe, 0x80, 0x3a, 0xa3, 0x31, 0x3f, 0x3a, 0x3e, 0x73, 0xcb, 0xeb,
	0x4e, 0xaf, 0x35, 0xf8, 0xa0, 0xbf, 0x08, 0xa7, 0xbe, 0x88, 0x74, 0x48, 0x63, 0xde, 0x17, 0x3f,
	0x8f, 0xce, 0x70, 0x8d, 0xc9, 0xaf, 0xf0, 0x3b, 0x09, 0x42, 0x4e, 0x62, 0xb7, 0xa2, 0xfc, 0xaa,
	0x19, 0xda, 0x06, 0x90, 0x7e, 0x69, 0x3c, 0x26, 0xb1, 0x5b, 0x95, 0xae, 0x7b, 0x05, 0x5c, 0x1f,
	0x08, 0x7d, 0xdc, 0x64, 0x66, 0x88, 0x3e, 0x87, 0x15, 0x05, 0xc9, 0xd1, 0x88, 0x8e, 0x09, 0x73,
	0x6b, 0xeb, 0xe5, 0x5e, 0x6b, 0x70, 0x43, 0xb9, 0x32, 0xf0, 0x1f, 0x2a, 0xd0, 0xb6, 0xe8, 0x98,
	0xe0, 0x65, 0xa5, 0x2e, 0xc6, 0x0c, 0xdd, 0x84, 0x66, 0xe4, 0x4f, 0x09, 0x9b, 0xf9, 0x23, 0xe2,
	0xd6, 0x65, 0x86, 0xe7, 0x0b, 0xde, 0x0f, 0xd0, 0x30, 0xc1, 0xbd, 0x01, 0xd4, 0xd4, 0xd6, 0xd0,
	0x32, 0xd4, 0x9f, 0xee, 0x7f, 0xb5, 0x7f, 0xf0, 0xcd, 0x7e, 0x7b, 0x09, 0x35, 0xa0, 0xb2, 0xbf,
	0xf9, 0xf5, 0xb0, 0xed, 0xa0, 0xab, 0x70, 0x65, 0x6f, 0xf3, 0xf0, 0xc9, 0x11, 0x1e, 0xee, 0x0d,
	0x37, 0x0f, 0x87, 0x8f, 0xdb, 0x25, 0xef, 0x3d, 0x68, 0xa6, 0x39, 0xa3, 0x3a, 0x94, 0x37, 0x0f,
	0xb7, 0x94, 0xc9, 0xe3, 0xe1, 0xe1, 0x56, 0xdb, 0xf1, 0x7e, 0x75, 0xa0, 0x63, 0x53, 0xc4, 0x66,
	0x34, 0x62, 0x44, 0x70, 0x34, 0xa2, 0x49, 0x94, 0x72, 0x24, 0x27, 0x08, 0x41, 0x25, 0x22, 0x2f,
	0x0d, 0x43, 0x72, 0x2c, 0x34, 0x39, 0xe5, 0x7e, 0x28, 0xd9, 0x29, 0x63, 0x35, 0x41, 0x0f, 0xa0,
	0xa1, 0xb7, 0xce, 0xdc, 0xca, 0x7a, 0xb9, 0xb7, 0x3c, 0xb8, 0x6e, 0x03, 0xa2, 0x23, 0xe2, 0x54,
	0xcd, 0xdb, 0x86, 0xb5, 0x6d, 0x62, 0x32, 0x51, 0x78, 0x99, 0x13, 0x23, 0xe2, 0xfa, 0x53, 0x22,
	0x93, 0x11, 0x71, 0xfd, 0x29, 0x41, 0x2e, 0xd4, 0xf5, 0x71, 0x93, 0xe9, 0x54, 0xb1, 0x99, 0x7a,
	0x1c, 0xdc, 0x8b, 0x8e, 0xf4, 0xbe, 0x16, 0x79, 0xfa, 0x10, 0x2a, 0xe2, 0x26, 0x48, 0x37, 0xcb,
	0x03, 0x64, 0xe7, 0xb9, 0x1b, 0x4d, 0x28, 0x96, 0x72, 0x9b, 0xaa, 0xf2, 0x3c, 0x55, 0x3b, 0xd9,
	0xa8, 0x5b, 0x34, 0xe2, 0x24, 0xe2, 0x6f, 0x96, 0xff, 0x1e, 0xdc, 0x58, 0xe0, 0x49, 0x6f, 0x60,
	0x03, 0xea, 0x3a, 0x35, 0xe9, 0x2d, 0x17, 0x57, 0xa3, 0xe5, 0xbd, 0x2a, 0x41, 0xe7, 0xe9, 0x6c,
	0xec, 0x73, 0x62, 0x44, 0x97, 0x24, 0x75, 0x07, 0xaa, 0xb2, 0xa2, 0x68, 0x2c, 0xae, 0x2a, 0xdf,
	0xaa, 0xec, 0x6c, 0x89, 0x5f, 0xac, 0xe4, 0xe8, 0x1e, 0xd4, 0x4e, 0xfd, 0x30, 0x21, 0x4c, 0x02,
	0x91, 0xa2, 0xa6, 0x35, 0x65, 0x39, 0xc2, 0x5a, 0x03, 0xad, 0x41, 0x7d, 0x1c, 0x9f, 0x89, 0x7a,
	0x22, 0xaf, 0x60, 0x03, 0xd7, 0xc6, 0xf1, 0x19, 0x4e, 0x22, 0x74, 0x1b, 0xae, 0x8c, 0x03, 0xe6,
	0x1f, 0x87, 0xe4, 0xe8, 0x39, 0xa5, 0x2f, 0x98, 0xbc, 0x85, 0x0d, 0xbc, 0xa2, 0x17, 0x77, 0xc4,
	0x1a, 0xea, 0x8a, 0x93, 0x34, 0x8a, 0x89, 0xcf, 0x89, 0x5b, 0x93, 0xf2, 0x74, 0x2e, 0x30, 0xe4,
	0xc1, 0x94, 0xd0, 0x84, 0xcb, 0xab, 0x53, 0xc6, 0x66, 0x8a, 0xde, 0x87, 0x95, 0x98, 0x30, 0xc2,
	0x8f, 0x74, 0x96, 0x0d, 0x69, 0xb9, 0x2c, 0xd7, 0x9e, 0xa9, 0xb4, 0x10, 0x54, 0x7e, 0xf2, 0x03,
	0xee, 0x36, 0xa5, 0x48, 0x8e, 0x95, 0x59, 0xc2, 0x88, 0x31, 0x03, 0x63, 0x96, 0x30, 0xa2, 0xcd,
	0x3a, 0x50, 0x9d, 0xd0, 0x78, 0x44, 0xdc, 0x65, 0x29, 0x53, 0x13, 0xef, 0x37, 0x07, 0xae, 0xcf,
	0xa1, 0xac, 0x09, 0x7b, 0x50, 0x8c, 0xb0, 0x9d, 0xa5, 0x94, 0x32, 0xf4, 0x10, 0xea, 0x21, 0x3d,
	0xd9, 0xe5, 0x64, 0xaa, 0x79, 0xb8, 0x95, 0x53, 0x97, 0x94, 0x92, 0x30, 0xd5, 0xfa, 0x8f, 0x40,
	0xa0, 0xa5, 0x22, 0x7b, 0xff, 0x38, 0xb0, 0x8a, 0x69, 0x18, 0x1e, 0xfb, 0xa3, 0x17, 0x05, 0xb8,
	0xcf, 0xd0, 0x54, 0xba, 0x9c, 0xa6, 0xf2, 0x02, 0x9a, 0x32, 0xc7, 0xb9, 0x62, 0x1d, 0x67, 0x8b,
	0xc0, 0x6a, 0x3e, 0x81, 0x35, 0x9b, 0x40, 0xc3, 0x4e, 0x3d, 0xc3, 0x4e, 0x0a, 0x7d, 0x23, 0x0b,
	0xfd, 0x1f, 0x0e, 0xac, 0x5d, 0xd8, 0xe6, 0x5b, 0x07, 0xff, 0xcf, 0x12, 0x5c, 0xdf, 0x8d, 0x18,
	0xf7, 0xc3, 0x70, 0x0e, 0xfb, 0xf4, 0x8e, 0x39, 0x85, 0xef, 0x58, 0xe9, 0xbf, 0xdc, 0xb1, 0xb2,
	0x45, 0x9e, 0x61, 0xba, 0x92, 0x61, 0xba, 0xd0, 0xbd, 0xb3, 0xaa, 0x5d, 0x6d, 0xae, 0xda, 0xa1,
	0x5b, 0x00, 0xea, 0xa2, 0x48, 0xe7, 0x8a, 0xa4, 0xa6, 0x5c, 0xd9, 0xd7, 0xc5, 0xcd, 0xf0, 0xda,
	0x58, 0xcc, 0x6b, 0xe6, 0xd6, 0x79, 0x3f, 0x43, 0x5d, 0xa3, 0x89, 0x1e, 0x42, 0x35, 0x24, 0xa7,
	0x24, 0x94, 0xe0, 0xb4, 0x06, 0xb7, 0x2f, 0xc5, 0xbe, 0xbf, 0x27, 0x54, 0xb1, 0xb2, 0x10, 0x31,
	0xa7, 0x84, 0x31, 0xff, 0x84, 0xe8, 0xf7, 0xc9, 0x4c, 0xbd, 0x9b, 0x50, 0x95, 0x9a, 0xe2, 0xe1,
	0xdb, 0xdd, 0xff, 0xf2, 0xa0, 0xbd, 0x84, 0x9a, 0x50, 0x1d, 0x62, 0x7c, 0x80, 0xdb, 0x8e, 0xf7,
	0xbb, 0x03, 0xab, 0xf3, 0x4c, 0xbd, 0xf5, 0xe3, 0xf3, 0x8b, 0x03, 0x6b, 0x4f, 0xa3, 0x60, 0xe1,
	0x01, 0x5a, 0x74, 0x79, 0x2f, 0x50, 0x5a, 0x5a, 0x40, 0x69, 0x07, 0xaa, 0xb3, 0x24, 0x3e, 0x21,
	0xfa, 0x88, 0xa8, 0x49, 0x96, 0xab, 0x8a, 0xc5, 0x95, 0xf7, 0x97, 0x03, 0xee, 0xc5, 0x24, 0xde,
	0x1c, 0x9b, 0x4e, 0xe6, 0xa1, 0x6d, 0xee, 0x2c, 0xe9, 0x67, 0x35, 0x83, 0x58, 0xf9, 0x7f, 0x20,
	0x76, 0x0d, 0xae, 0x6e, 0x13, 0xfe, 0x4c, 0x15, 0x1d, 0x0d, 0x95, 0x37, 0x04, 0x94, 0x5d, 0x3c,
	0x7f, 0x43, 0xf5, 0x92, 0x9d, 0xba, 0x69, 0x5f, 0x8d, 0xbe, 0xd1, 0xf2, 0x1e, 0x4a, 0xdf, 0x3b,
	0x01, 0xe3, 0x34, 0x3e, 0xbb, 0x8c, 0x86, 0x36, 0x94, 0xa7, 0xfe, 0x4b, 0xfd, 0xa0, 0x8b, 0xa1,
	0xb7, 0x2d, 0x33, 0x48, 0x4d, 0x53, 0xf0, 0xce, 0xdb, 0x23, 0xa7, 0x58, 0x7b, 0xf4, 0x1d, 0xa0,
	0x27, 0x24, 0xed, 0xd4, 0x5e, 0xd3, 0x59, 0x18, 0x42, 0x4b, 0xf6, 0xe5, 0x73, 0xa1, 0x3e, 0x0a,
	0x89, 0x1f, 0x25, 0x33, 0x7d, 0x04, 0xcc, 0xd4, 0xfb, 0x1e, 0xae, 0x59, 0xde, 0x75, 0x9e, 0x62,
	0x3f, 0xec, 0x44, 0x7b, 0x17, 0x43, 0xf4, 0x19, 0xd4, 0x54, 0xfb, 0x2a, 0x7d, 0xb7, 0x06, 0x37,
	0xed, 0xbc, 0xa5, 0x93, 0x24, 0xd2, 0xfd, 0x2e, 0xd6, 0xba, 0x83, 0x57, 0x0d, 0x68, 0x99, 0x86,
	0x4c, 0xd1, 0x8a, 0x02, 0x58, 0xc9, 0x76, 0x9e, 0xe8, 0x6e, 0x7e, 0xef, 0x3d, 0xf7, 0x07, 0x44,
	0xf7, 0x5e, 0x11, 0x55, 0x7d, 0x2c, 0x96, 0x3e, 0x71, 0x10, 0x83, 0xf6, 0x7c, 0x43, 0x88, 0xee,
	0x2f, 0xf6, 0x91, 0xd3, 0x81, 0x76, 0xfb, 0x45, 0xd5, 0x4d, 0x58, 0x74, 0x2a, 0xcf, 0x8c, 0xdd,
	0xc5, 0xa1, 0xd7, 0xba, 0xb1, 0x1b, 0xc7, 0xee, 0x46, 0x61, 0xfd, 0x34, 0x6e, 0x08, 0x57, 0xac,
	0x46, 0x04, 0xe5, 0xa0, 0xb5, 0xa8, 0x27, 0xec, 0x7e, 0x54, 0x48, 0x37, 0x03, 0x2d, 0x85, 0x96,
	0x5d, 0x3b, 0x51, 0x8e, 0x8b, 0x85, 0x6f, 0x61, 0xf7, 0xe3, 0x62, 0xca, 0x99, 0x80, 0x09, 0xb4,
	0xe7, 0x4b, 0x52, 0x1e, 0x97, 0x39, 0xf5, 0x33, 0x8f, 0xcb, 0xbc, 0x4a, 0x27, 0xc3, 0xfa, 0x00,
	0xe7, 0x85, 0x04, 0xdd, 0xc9, 0xa5, 0xc5, 0xae, 0x3f, 0xdd, 0xde, 0xeb, 0x15, 0x53, 0xe2, 0x62,
	0x78, 0x67, 0xae, 0x8d, 0x41, 0x39, 0xf0, 0x2c, 0x6e, 0xea, 0xba, 0xf7, 0x0b, 0x6a, 0x5f, 0xd8,
	0x96, 0xae, 0x4e, 0x97, 0x6c, 0xcb, 0x2e, 0x7d, 0x97, 0x6c, 0x6b, 0xae, 0xd0, 0x79, 0x4b, 0x28,
	0x80, 0x16, 0x4e, 0x22, 0x1d, 0x5c, 0x94, 0x07, 0x94, 0x63, 0x7d, 0xb1, 0xba, 0x75, 0xef, 0x16,
	0xd0, 0x3c, 0xdf, 0xcd, 0x23, 0xf8, 0xb6, 0x61, 0x54, 0x8f, 0x6b, 0xf2, 0x7f, 0x10, 0x9f, 0xfe,
	0x1b, 0x00, 0x00, 0xff, 0xff, 0xa9, 0x91, 0x95, 0xc1, 0x71, 0x11, 0x00, 0x00,
}
